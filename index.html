<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Introduction to Ruby</title>
    <meta content="" name="description" />
    <meta content="" name="author" />
    <link href="css/reveal.css" rel="stylesheet" />
    <link href="css/simple.css" rel="stylesheet" />
    <link href="css/googlecode.css" rel="stylesheet" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section class="center" data-background="#000">
  <h1 class="white">
    Konnichiwa Ruby
  </h1>
</section>
<section>
  <h2>
    Variables
  </h2>
  <p>
    The variables assign a name to something
  </p>
  <pre><code>munchies = "chunky bacon" # No need for declaration
name = something          # The basic form </code></pre>
</section>
<section>
  <h2>
    Variables
  </h2>
  <p>
    A name can point to any type
  </p>
  <pre><code class="ruby">an_integer = 42
a_float = 3.14
a_string = "this is a string literal"
an_object = Object.new </code></pre>
</section>
<section>
  <h2>
    Variables
  </h2>
  <p>
    Nothing is copied, everything is referential
  </p>
  <pre><code class="ruby">>> mood = "happy"
=> "happy"
>> downer = mood
=> "happy"
>> downer["happy"] = "sad"
=> "sad"
>> mood
=> "sad" </code></pre>
</section>
<section>
  <h2>
    Variables
  </h2>
  <p>
    And the type can be changed midway
  </p>
  <pre><code class="ruby">a_string = 42         # Whether that is a good idea
a_string = Object.new # is left as an excersice ;) </code></pre>
</section>
<section>
  <h2>
    Global Variables
  </h2>
  <p>
    Global variables are visible from everywhere
  </p>
  <pre><code class="ruby">$do_you_really_need_that = "no" </code></pre>
</section>
<section>
  <h2>
    Constants
  </h2>
  <p>
    Constants start with a capital letter
  </p>
  <pre><code class="ruby">ANSWER = 42            # This is a constant!
Europe = Continent.new # So is this! </code></pre>
</section>
<section>
  <h2>
    Constants
  </h2>
  <p>
    Constants are not strictly enforced
  </p>
  <pre><code class="ruby">>> Foo = 42
=> 42
>> Foo = 43
(irb):40: warning: already initialized constant Foo
(irb):39: warning: previous definition of Foo was here
=> 43 </code></pre>
</section>
<section class="center" data-background="#000">
  <p class="white">
    Naming is important
  </p>
</section>
<section class="center" data-background="#000">
  <p class="white">
    Don't be sloppy with it
  </p>
</section>
<section class="center" data-background="#000">
  <p class="white">
    Code lives a long time
  </p>
</section>
<section class="center" data-background="#000">
  <p class="white">
    You want to understand it 1 year from now
  </p>
</section>
<section class="center" data-background="#000">
  <p class="white">
    You want to understand it 5 year from now
  </p>
</section>
<section class="center">
  <pre><code class="ruby">everything = 42
pi = 3.14 </code></pre>
</section>
<section>
  <h2>
    Identifiers
  </h2>
  <ul>
    <li>
      alphanumeric characters (A-Za-z0-9)
    </li>
    <li class="fragment">
      underscores (_)
    </li>
    <li class="fragment">
      may not begin with a digit (0-9)
    </li>
  </ul>
</section>
<section>
  <h2>
    Identifiers
  </h2>
  <ul>
    <li>
      identifiers that are method names may
    </li>
    <li class="fragment">
      end with a question mark (?)
    </li>
    <li class="fragment">
      end with a exclamation point (!)
    </li>
    <li class="fragment">
      end with equals sign (=)
    </li>
  </ul>
</section>
<section>
  <h2>
    Reserved Words
  </h2>
  <pre><code class="ruby">__FILE__  and    def       end     in      or      self   unless
__LINE__  begin  defined?  ensure  module  redo    super  until
BEGIN     break  do        false   next    rescue  then   when
END       case   else      for     nil     retry   true   while
alias     class  elsif     if      not     return  undef  yield </code></pre>
</section>
<section>
  <h2>
    Integer
  </h2>
  <p>
    You can represent integers with the following literals
  </p>
  <pre><code class="ruby">123456  # Fixnum
123_456 # Fixnum (underscore ignored)
-543    # Negative Fixnum </code></pre>
</section>
<section>
  <h2>
    Integer
  </h2>
  <p>
    If the integer literal is too big, it will switch to a big number type
  </p>
  <pre><code class="ruby">123456                  # Fixnum
123_456_789_123_345_789 # Bignum (2 ** 62 onwards) </code></pre>
</section>
<section>
  <h2>
    Integer
  </h2>
  <p>
    You can represent integers in hexadecimal, octal and binary forms
  </p>
  <pre><code class="ruby">0xaabb     # Hexadecimal (Fixnum)
0377       # Octal (Fixnum)
-0b101_010 # Binary (Fixnum) </code></pre>
</section>
<section>
  <h2>
    Integer
  </h2>
  <p>
    Fixnum and Bignum have Integer as a base class
  </p>
  <pre><code class="ruby">=> Bignum
>> Integer > Fixnum
=> true
>> Integer > Bignum
=> true </code></pre>
</section>
<section class="center" data-background="#000">
  <p class="white">
    Everything in Ruby is an object
  </p>
</section>
<section class="center" data-background="#000">
  <p class="white">
    Objects have actions
  </p>
</section>
<section class="center" data-background="#000">
  <p class="white">
    universe.expand
  </p>
</section>
<section class="center" data-background="#000">
  <p class="white">
    universe.kill_them_all_eventually
  </p>
</section>
<section class="center" data-background="#000">
  <p class="white">
    We call those actions methods
  </p>
</section>
<section class="center" data-background="#000">
  <p class="white">
    Don't worry too much about them for now
  </p>
</section>
<section>
  <h2>
    Integer
  </h2>
  <p>
    As every object, integers respond to methods
  </p>
  <pre><code class="ruby">>> 3.times { puts "♪ ruby ♪" }
♪ ruby ♪
♪ ruby ♪
♪ ruby ♪
=> 3 </code></pre>
</section>
<section>
  <h2>
    Integer
  </h2>
  <p>
    As every object, integers respond to methods
  </p>
  <pre><code class="ruby">>> 16.even?
=> true </code></pre>
</section>
<section>
  <h2>
    Floats
  </h2>
  <p>
    Floats can be expressed by scientific notation
  </p>
  <pre><code class="ruby">3.1415926 # Float
6.022e23  # Float </code></pre>
</section>
<section>
  <h2>
    Floats
  </h2>
  <p>
    Floats will be floats
  </p>
  <pre><code class="ruby">>> 0.1 + 0.2
=> 0.30000000000000004
>> 0.1 + 0.2 == 0.3
=> false </code></pre>
</section>
<section>
  <h2>
    Rational
  </h2>
  <p>
    A nice little addition
  </p>
  <pre><code class="ruby">1/2r # Rational </code></pre>
</section>
<section class="center" data-background="#000">
  <p class="white">
    Spoiler alert
  </p>
</section>
<section>
  <h2>
    Numbers
  </h2>
  <p>
    There are complex and big decimal implementations
  </p>
  <pre><code class="ruby">>> require 'complex'
=> true
>> Complex '1i'
=> (0+1i) </code></pre>
</section>
<section>
  <h2>
    Numbers
  </h2>
  <p>
    There are complex and big decimal implementations
  </p>
  <pre><code class="ruby">>> require 'bigdecimal'
=> true
>> BigDecimal('125') / BigDecimal('100000')
=> #<BigDecimal:7f9c2b070610,'0.125E-2',9(36)> </code></pre>
</section>
<section class="center" data-background="#000">
  <p class="white">
    If you need to store money, do that in BigDecimal
  </p>
</section>
<section>
  <h2>
    TrueClass
  </h2>
  <p>
    The boolean truth
  </p>
  <pre><code class="ruby">'He said "Hello, mister"...'
"He said, \"There are miltiline\nstrings\"..." </code></pre>
</section>
<section>
  <h2>
    String
  </h2>
  <p>
    Can be written with single and double quotes
  </p>
  <pre><code class="ruby">'He said "Hello, mister"...'
"He said, \"There are miltiline\nstrings\"..." </code></pre>
</section>
<section>
  <h2>
    String
  </h2>
  <p>
    The two notations are not the same (unlike Python)
  </p>
  <pre><code class="ruby">>> '\n' == "\n"
=> false
>> "42" == '42'
=> false </code></pre>
</section>
<section>
  <h2>
    String
  </h2>
  <p>
    Are mutable, which may surprise you
  </p>
  <pre><code class="ruby">>> weather = "raining"
=> "raining"
>> weather["rain"] = "snow"
=> "snow"
>> weather
=> "snowing" </code></pre>
</section>
<section>
  <h2>
    Symbols
  </h2>
  <p>
    Symbols are like lightweight strings
  </p>
  <pre><code class="ruby">:a_symbol
:symbols_literals_should_be_valid_identifiers!
:"if not, they have to be written like this"
:'which looks kinda funny' </code></pre>
</section>
<section>
  <h2>
    Symbols
  </h2>
  <p>
    Interned, meaning they always yield the same object
  </p>
  <pre><code class="ruby">>> :chunky.object_id == :chunky.object_id
=> true
>> "chunky".object_id == "chunky".object_id
=> false </code></pre>
</section>
<section>
  <h2>
    Symbols
  </h2>
  <p>
    Memory leaks, once defined they are never garbage collected
  </p>
  <pre><code class="ruby">>> :chunky.object_id == :chunky.object_id
=> true
>> "chunky".object_id == "chunky".object_id
=> false </code></pre>
</section>
<section>
  <h2>
    Symbols
  </h2>
  <p>
    You'll use them for internal representations
  </p>
</section>
<section class="center" data-background="#000">
  <p class="white">
    Nobody gets the first time, its okay
  </p>
</section>
<section>
  <h2>
    The Truth
  </h2>
  <p>
    Everything is true<span class="fragment">, except nil and false</span>
  </p>
</section>
<section>
  <h2>
    TrueClass
  </h2>
  <ul>
    <li>
      There is no strict Boolean class in Ruby
    </li>
    <li>
      The boolean truth is represented by true, the single instance of TrueClass
    </li>
  </ul>
  <pre><code class="ruby">>> true.class.ancestors
=> [TrueClass, Object, Kernerl, BasicObject] </code></pre>
</section>
<section>
  <h2>
    FalseClass
  </h2>
  <ul>
    <li>
      There is no strict Boolean class in Ruby
    </li>
    <li>
      The boolean false is represented by false, the single instance of FalseClass
    </li>
  </ul>
  <pre><code class="ruby">>> false.class.ancestors
=> [FalseClass, Object, Kernerl, BasicObject] </code></pre>
</section>
<section class="center" data-background="#000">
  <blockquote class="white">I call it my billion-dollar mistake.</blockquote>
  <p class="white">
    Tony Hoare
  </p>
</section>
<section>
  <h2>
    NilClass
  </h2>
  <p>
    When there is nothing to return
  </p>
  <pre><code class="ruby">>> def foo; end
=> :foo
>> foo
=> nil </code></pre>
</section>
<section>
  <h2>
    Operators
  </h2>
  <pre>Method  Operator
Y       [ ] [ ]=
Y       **
Y       ! ~
Y       * / %
Y       + -
Y       >> <<
Y       &
Y       ^ |
Y       <= < > >=
Y       <=> == === != =~ !~	
        &&	
        ||
        .. ...
        ? :
        = %= { /= -= += |= &= >>= <<= *= &&= ||= **=
        defined?
        not
        or and
        if unless while until
        begin/end </pre>
</section>
<section>
  <h2>
    Operators
  </h2>
  <p>
    Operators don't return a strict Boolean
  </p>
  <pre><code class="ruby">>> nil || 42
=> 42
>> nil && 42
=> nil </code></pre>
</section>
<section>
  <h2>
    If
  </h2>
  <p>
    The if statement executes a block of code if its condition is truthy
  </p>
  <pre><code class="ruby">if bear.hungry?
  bear.eat
elsif bear.thirsty?
  bear.drink
else
  bear.dance
end </code></pre>
</section>
<section>
  <h2>
    If
  </h2>
  <p>
    The if statement executes a block of code if its condition is truthy
  </p>
  <pre><code class="ruby">if bear.hungry? then
  bear.eat
elsif bear.thirsty? then
  bear.drink
else
  bear.dance
end </code></pre>
</section>
<section>
  <h2>
    If
  </h2>
  <p>
    The last executed code in an if statement is its return value
  </p>
  <pre><code class="ruby">consequence = if bear.hungry?
                bear.eat
              elsif bear.thirsty?
                bear.drink
              else
                bear.dance
              end </code></pre>
</section>
<section>
  <h2>
    If
  </h2>
  <p>
    Its actually an expression
  </p>
  <pre><code class="ruby">consequence = if bear.hungry?
                bear.eat
              elsif bear.thirsty?
                bear.drink
              else
                bear.dance
              end </code></pre>
</section>
<section>
  <h2>
    If
  </h2>
  <p>
    It returns nil if no condition matches
  </p>
  <pre><code class="ruby">this_can_be_nil = if bear.hungry?
                    bear.eat
                  elsif bear.thirsty?
                    bear.drink
                  end </code></pre>
</section>
<section class="center" data-background="#000">
  <p class="white">
    Everything is an expression in Ruby
  </p>
</section>
<section>
  <h2>
    Postfix If
  </h2>
  <p>
    You can use if as an expression modifier
  </p>
  <pre><code class="ruby">sleep if tired? </code></pre>
</section>
<section>
  <h2>
    Unless
  </h2>
  <p>
    The unless statement executes a block of code if its condition is falsy
  </p>
  <pre><code class="ruby">unless response.redirect?
  process response.body
else
  follow response['location']
end </code></pre>
</section>
<section>
  <h2>
    Unless
  </h2>
  <p>
    There is no elsif clause
  </p>
  <pre><code class="ruby">unless response.redirect?
  process response.body
# There is no such thing as unlessif :)
else
  follow response['location']
end </code></pre>
</section>
<section>
  <h2>
    Unless
  </h2>
  <p>
    Is an expression modifier
  </p>
  <pre><code class="ruby">eat unless hungry? </code></pre>
</section>
<section class="center" data-background="#000">
  <p class="white">
    Unless else is hard to process, mentally
  </p>
</section>
<section class="center" data-background="#000">
  <p class="white">
    Use with caution
  </p>
</section>
<section>
  <h2>
    Case
  </h2>
  <p>
    A multiway if on steroids
  </p>
  <pre><code class="ruby">case year
when 1850..1889
  :blues
when 1890..1909
  :ragtime
when 1910..1929
  :new_orlean_jazz
when 1930..1939
  :swing
when 1940..1950
  :bebop
else
  :jazz
end </code></pre>
</section>
<section>
  <h2>
    Case
  </h2>
  <p>
    A multiway if on steroids
  </p>
  <pre><code class="ruby">case year
when 1850..1889 then :blues
when 1890..1909 then :ragtime
when 1910..1929 then :new_orlean_jazz
when 1930..1939 then :swing
when 1940..1950 then :bebop
else                 :jazz
end </code></pre>
</section>
<section>
  <h2>
    Case
  </h2>
  <p>
    A multiway if on steroids
  </p>
  <pre><code class="ruby">genre = case year
        when 1850..1889 then :blues
        when 1890..1909 then :ragtime
        when 1910..1929 then :new_orlean_jazz
        when 1930..1939 then :swing
        when 1940..1950 then :bebop
        else                 :jazz
        end </code></pre>
</section>
<section>
  <h2>
    Case
  </h2>
  <p>
    The case condition can be skipped
  </p>
  <pre><code class="ruby">case
when (1850..1889) === year
  :blues
when (1890..1909) === year
  :ragtime
when (1910..1929) === year
  :new_orlean_jazz
when (1930..1939) ==== year
  :swing
when (1940..1950) === year
  :bebop
else
  :jazz
end </code></pre>
</section>
<section>
  <h2>
    Case
  </h2>
  <p>
    It will become true, implicitly
  </p>
  <pre><code class="ruby">case true
when (1850..1889) === year
  :blues
when (1890..1909) === year
  :ragtime
when (1910..1929) === year
  :new_orlean_jazz
when (1930..1939) ==== year
  :swing
when (1940..1950) === year
  :bebop
else
  :jazz
end </code></pre>
</section>
<section>
  <h2>
    Case
  </h2>
  <p>
    Objects responding to #=== can be used in when
  </p>
  <pre><code class="ruby">case
when (1850..1889) === year
  :blues
when (1890..1909) === year
  :ragtime
when (1910..1929) === year
  :new_orlean_jazz
when (1930..1939) ==== year
  :swing
when (1940..1950) === year
  :bebop
else
  :jazz
end </code></pre>
</section>
<section>
  <h2>
    While
  </h2>
  <p>
    Iterates while a condition is truthy
  </p>
  <pre><code class="ruby">while hungry?
  eat
end </code></pre>
</section>
<section>
  <h2>
    While
  </h2>
  <p>
    Is an expression modifier
  </p>
  <pre><code class="ruby">eat while hungry? </code></pre>
</section>
<section>
  <h2>
    Until
  </h2>
  <p>
    Iterates while a condition is falsy
  </p>
  <pre><code class="ruby">untill full?
  eat
end </code></pre>
</section>
<section>
  <h2>
    Until
  </h2>
  <p>
    Is an expression modifier
  </p>
  <pre><code class="ruby">eat until full? </code></pre>
</section>
<section>
  <h2>
    For
  </h2>
  <p>
    Don't use for in Ruby
  </p>
  <pre><code class="ruby">for color in spectrum
  color.inverse
end </code></pre>
</section>
<section>
  <h2>
    For
  </h2>
  <p>
    An anti-pattern
  </p>
  <pre><code class="ruby">for color in spectrum
  color.inverse
end </code></pre>
</section>
<section>
  <h2>
    For
  </h2>
  <p>
    Calls #each under the hood
  </p>
  <pre><code class="ruby">>> for letter in "abcdefg..."
>>   say letter
>> end
NoMethodError: undefined method `each' for "abcdefg...":String </code></pre>
</section>
<section class="center" data-background="#000">
  <p>
    What is #each?
  </p>
</section>
<section class="center" data-background="#000">
  <p class="white">
    We'll find out next week!
  </p>
</section>
<section>
  <p class="white">
    See you next time!
  </p>
</section>
      </div>
    </div>
    <script src="js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script type="text/javascript">
      Reveal.initialize({
        width:  '100%',
        height: '100%',
        margin: 0.05,
        controls: false,
        progress: false,
        history: true,
        center: false,
        rollingLinks: true,
        transition: 'none',
        backgroundTransition: 'none',
        dependencies: [
          {
            src: 'js/highlight.js',
            async: true,
            callback: function() {
              hljs.configure({ languages: ['ruby'] });
              hljs.initHighlightingOnLoad();
            }
          }
        ]
      });
    </script>
  </body>
</html>