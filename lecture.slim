section.center data-background="#000"
  h1.white Konnichiwa Ruby

section
  h2 Variables
  p The variables assign a name to something
  pre: code
    '
      munchies = "chunky bacon" # No need for declaration
      name = something          # The basic form

section
  h2 Variables
  p A name can point to any type
  pre: code.ruby
    '
      an_integer = 42
      a_float = 3.14
      a_string = "this is a string literal"
      an_object = Object.new

section
  h2 Variables
  p Nothing is copied, everything is referential
  pre: code.ruby
    '
      >> mood = "happy"
      => "happy"
      >> downer = mood
      => "happy"
      >> downer["happy"] = "sad"
      => "sad"
      >> mood
      => "sad"

section
  h2 Variables
  p And the type can be changed midway
  pre: code.ruby
    '
      a_string = 42         # Whether that is a good idea
      a_string = Object.new # is left as an excersice ;)

section
  h2 Global Variables
  p Global variables are visible from everywhere
  pre: code.ruby
    '
      $do_you_really_need_that = "no"

section
  h2 Constants
  p Constants start with a capital letter
  pre: code.ruby
    '
      ANSWER = 42            # This is a constant!
      Europe = Continent.new # So is this!

section
  h2 Constants
  p Constants are not strictly enforced
  pre: code.ruby
    '
      >> Foo = 42
      => 42
      >> Foo = 43
      (irb):40: warning: already initialized constant Foo
      (irb):39: warning: previous definition of Foo was here
      => 43
      >>

section.center data-background="#000"
  p.white Naming is an important part of the code

section.center data-background="#000"
  p.white Don't be sloppy with it

section.center data-background="#000"
  p.white Code lives a long time

section.center data-background="#000"
  p.white You want to understand it 1 year from now

section.center data-background="#000"
  p.white You want to understand it 5 year from now

section.center
  pre: code.ruby
    '
      everything = 42
      pi = 3.14

section
  h2 Identifiers
  ul
    li alphanumeric characters (A-Za-z0-9)
    li.fragment underscores (_)
    li.fragment may not begin with a digit (0-9)

section
  h2 Identifiers
  ul
    li identifiers that are method names may
    li.fragment end with a question mark (?)
    li.fragment end with a exclamation point (!)
    li.fragment end with equals sign (=)

section
  h2 Reserved Words
  pre: code.ruby
    '
      __FILE__  and    def       end     in      or      self   unless
      __LINE__  begin  defined?  ensure  module  redo    super  until
      BEGIN     break  do        false   next    rescue  then   when
      END       case   else      for     nil     retry   true   while
      alias     class  elsif     if      not     return  undef  yield

section
  h2 Integer
  p You can represent integers with the following literals
  pre: code.ruby
   '
     123456  # Fixnum
     123_456 # Fixnum (underscore ignored)
     -543    # Negative Fixnum

section
  h2 Integer
  p If the integer literal is too big, it will switch to a big number type
  pre: code.ruby
   '
     123456                  # Fixnum
     123_456_789_123_345_789 # Bignum (2 ** 62 onwards)

section
  h2 Integer
  p You can represent integers in hexadecimal, octal and binary forms
  pre: code.ruby
    '
      0xaabb     # Hexadecimal (Fixnum)
      0377       # Octal (Fixnum)
      -0b101_010 # Binary (Fixnum)

section
  h2 Integer
  p Fixnum and Bignum have Integer as a base class
  pre: code.ruby
    '
      => Bignum
      >> Integer > Fixnum
      => true
      >> Integer > Bignum
      => true

section.center data-background="#000"
  p.white Everything in Ruby is an object

section.center data-background="#000"
  p.white Objects have actions

section.center data-background="#000"
  p.white universe.expand

section.center data-background="#000"
  p.white universe.kill_them_all_eventually

section.center data-background="#000"
  p.white We call those actions methods

section.center data-background="#000"
  p.white Don't worry too much about them for now

section
  h2 Integer
  p As every object, integers respond to methods
  pre: code.ruby
    '
      >> 3.times { puts "♪ ruby ♪" }
      ♪ ruby ♪
      ♪ ruby ♪
      ♪ ruby ♪
      => 3

section
  h2 Integer
  p As every object, integers respond to methods
  pre: code.ruby
    '
      >> 16.even?
      => true

section
  h2 Floats
  p Floats can be expressed by scientific notation
  pre: code.ruby
    '
      3.1415926 # Float
      6.022e23  # Float

section
  h2 Floats
  p Floats will be floats
  pre: code.ruby
    '
      >> 0.1 + 0.2
      => 0.30000000000000004
      >> 0.1 + 0.2 == 0.3
      => false

section
  h2 Rational
  p A nice little addition
  pre: code.ruby
    '
      1/2r # Rational

section.center data-background="#000"
  p.white Spoiler alert

section
  h2 Numbers
  p There are complex and big decimal implementations
  pre: code.ruby
    '
      >> require 'complex'
      => true
      >> Complex '1i'
      => (0+1i)

section
  h2 Numbers
  p There are complex and big decimal implementations
  pre: code.ruby
    '
      >> require 'bigdecimal'
      => true
      >> BigDecimal('125') / BigDecimal('100000')
      => #<BigDecimal:7f9c2b070610,'0.125E-2',9(36)>

section.center data-background="#000"
  p.white If you need to store money, do that in BigDecimal

section
  h2 TrueClass
  p The "formal" truth
  pre: code.ruby
    '
      'He said "Hello, mister"...'
      "He said, \"There are miltiline\nstrings\"..."

section
  h2 String
  p They can be written with single and double quotes
  pre: code.ruby
    '
      'He said "Hello, mister"...'
      "He said, \"There are miltiline\nstrings\"..."

section
  h2 String
  p The two notations are not the same (unlike Python)
  pre: code.ruby
    '
      >> '\n' == "\n"
      => false
      >> "#{42}" == '#{42}'
      => false

section
  h2 String
  p Are mutable, which may surprise you
  pre: code.ruby
    '
      >> weather = "raining"
      => "raining"
      >> weather["rain"] = "snow"
      => "snow"
      >> weather
      => "snowing"

section
  h2 Symbols
  p Symbols are like lightweight strings
  pre: code.ruby
    '
      :a_symbol
      :symbols_literals_should_be_valid_identifiers!
      :"if not, they have to be written like this"
      :'which looks kinda funny'

section
  h2 Symbols
  p They are interned, meaning they always yield the same object
  pre: code.ruby
    '
      >> :chunky.object_id == :chunky.object_id
      => true
      >> "chunky".object_id == "chunky".object_id
      => false

section
  h2 Symbols
  p You'll use them for internal representations

section.center data-background="#000"
  p.white Nobody gets the first time, its okay

section
  h2 The Truth
  p
    | Everything is true
    span.fragment, except nil and false

section
  h2 TrueClass
  ul
    li There is no Boolean class in Ruby
    li The formal truth is represented by true
  pre: code.ruby
    '
      >> true.class.ancestors
      => [TrueClass, Object, Kernerl, BasicObject]

section
  h2 FalseClass
  ul
    li There is no Boolean class in Ruby
    li The formal lie is represented by true
  pre: code.ruby
    '
      >> false.class.ancestors
      => [FalseClass, Object, Kernerl, BasicObject]

section.center data-background="#000"
  blockquote.white I call it my billion-dollar mistake.
  p.white Tony Hoare

section
  h2 NilClass
  p When there is nothing to return
  pre: code.ruby
    '
      >> def foo; end
      => :foo
      >> foo
      => nil

section
  h2 Operators
  pre
    '
      Method  Operator
      Y       [ ] [ ]=
      Y       **
      Y       ! ~
      Y       * / %
      Y       + -
      Y       >> <<
      Y       &
      Y       ^ |
      Y       <= < > >=
      Y       <=> == === != =~ !~	
              &&	
              ||
              .. ...
              ? :
              = %= { /= -= += |= &= >>= <<= *= &&= ||= **=
              defined?
              not
              or and
              if unless while until
              begin/end

section
  h2 Operators
  ul
    li They won't return strict true or false
    li Rather the last truthy of falsy value
